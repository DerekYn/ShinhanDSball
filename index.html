<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ¦– Shinhan bouncy ball</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background:#111;
      color:#ddd;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;           /* ìŠ¤í¬ë¡¤ ì œê±° */
      touch-action: none;
      overscroll-behavior: contain;
    }
    .wrap {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:8px;
      width:100%;
      height:100%;
      box-sizing:border-box;
      padding:12px;
    }
    .title {
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 6px;
      text-align: center;
      user-select: none;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#000;
      border:2px solid #444;
      max-width:96vw;
      max-height:70dvh;
    }
    .hud { font-size: 14px; opacity: .9; text-align:center; user-select: none; }
    .hud kbd { background:#222; border:1px solid #444; border-bottom-color:#222; padding:1px 6px; border-radius:4px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .controls { display:flex; gap:12px; user-select:none; }
    .controls button { font-size:20px; padding:14px 18px; border-radius:12px; background:#222; color:#eee; border:1px solid #555; cursor:pointer; min-width:64px; }
    .controls button:active { transform: translateY(1px); }
    .overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.5); backdrop-filter: blur(2px); z-index:10; }
    .overlay.hidden { display:none; }
    .modal { min-width: min(90vw, 440px); max-width: 92vw; background:#1c1c1c;
      border:1px solid #444; border-radius:12px; padding:16px 18px; box-shadow:0 8px 30px rgba(0,0,0,.5); }
    .modal h2 { margin:0 0 8px; font-size:20px; }
    .modal .body { white-space:pre-line; line-height:1.45; margin-bottom:12px; }
    .actions { display:flex; gap:10px; justify-content:flex-end; }
    .actions button { padding:8px 12px; border-radius:10px; border:1px solid #555; background:#2a2a2a; color:#eee; cursor:pointer; }
    .actions .primary { background:#3b82f6; border-color:#2a6adf; color:#fff; }
    .actions button:active { transform:translateY(1px); }
  </style>
</head>
<body>
<div class="wrap">
  <div class="title" id="pageTitle"> ğŸ¦– Shinhan bouncy ball </div>
  <canvas id="game" width="640" height="480"></canvas>
  <div class="hud">
    ë°©í–¥ë§Œ ì¡°ì‘ â†’ <kbd>â—€</kbd>/<kbd>â–¶</kbd> (ë˜ëŠ” <kbd>A</kbd>/<kbd>D</kbd>) Â· ì¼ì‹œì •ì§€ <kbd>P</kbd>
  </div>
  <div class="controls">
    <button id="btnLeft"  aria-label="Left">â—€</button>
    <button id="btnPause" aria-label="Pause">â¸</button>
    <button id="btnRight" aria-label="Right">â–¶</button>
  </div>
</div>

<div id="overlay" class="overlay hidden">
  <div class="modal">
    <h2 id="ovTitle">ì•Œë¦¼</h2>
    <div id="ovBody" class="body">ë‚´ìš©</div>
    <div class="actions">
      <button id="btnRestartStage1" class="primary">ìŠ¤í…Œì´ì§€ 1ë¶€í„° ë‹¤ì‹œ</button>
      <button id="btnCloseOverlay">ë‹«ê¸°</button>
    </div>
  </div>
</div>

<script>
/* =======================
   ìŠ¤í…Œì´ì§€ ì •ì˜ (ê³ ì •)
======================= */
const level1_base = [
  "RRRRRRRRRRRRRRRRRRRR",
  "R..................R",
  "R.S................R",
  "R..................R",
  "R..................R",
  "R.....RRRRRRR......R",
  "R....RR..RRRR......R",
  "R...RRR.R.RRR......R",
  "R..RRRR.R.RRR......R",
  "R.RRRRR..RRRR......R",
  "RRRRRRRRR...RWWWWWWR",
  "RRRRRRRRR.RRR......R",
  "RRRRRRRRRR.RR......R",
  "RRRRRRRRRRR.R......G",
  "RRRRRRRRR...RRRRRRRR"
];
const level2_base = [
  "RRRRRRRRRRRRRRRRRRRR",
  "R..................R",
  "R.S...RR...........R",
  "R.....R.R..........R",
  "R.....R.R...RRR....R",
  "R.....R.R...R......R",
  "R.....RR.....R.....R",
  "R.............R....R",
  "R...........RRR....R",
  "R..................R",
  "R..................R",
  "RRRRR..............G",
  "RRRRR....RRRR.RRRRRR",
  "RRRRR.RRRRR........R",
  "RRRRR.RRRRR........R"
];
const level3_base = [
  "RRRRRRRRRRRRRRRRRRRR",
  "R..................R",
  "R.S................R",
  "R..................R",
  "R..................R",
  "R..................R",
  "R..................R",
  "R..............JJ..R",
  "R...........J......G",
  "R........J........RR",
  "R.....J............R",
  "R...R..............R",
  "R..R...............R",
  "R..................R",
  "RRRRR..............R"
];
const level4_base = [
  "RRRRRRRRRRRRRRRRRRRR",
  "R..................R",
  "R.S................R",
  "R..................R",
  "R..................R",
  "RRRRRWWWWWRRRRRRRRRR",
  "R...........R......R",
  "R...........R......R",
  "R...........R......R",
  "R...........R......R",
  "R...........R......R",
  "R..................R",
  "R..................G",
  "R....RRRRWWWWJ.RRRRR",
  "R..............RRRRR"
];
const level5_base = [
  "RRRRRRRRRRRRRRRRRRRR",
  "R................S.R",
  "R..................R",
  "R..................R",
  "R.....RRBRRRBRRRRRRR",
  "R................R.R",
  "R................R.R",
  "RBBRRR>..........R.R",
  "R......BBBBBB....R.R",
  "R................R.R",
  "R................R.R",
  "R................R.R",
  "R.....RRRRRRRRRRRR.R",
  "R..................G",
  "R...>..............G"
];

/* =======================
   ê²Œì„ ì—”ì§„
======================= */
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const TILE = 16, COLS = Math.floor(W/TILE), ROWS = Math.floor(H/TILE);

  // ë¬¼ë¦¬ ìƒìˆ˜
  const GRAVITY = 1200;     // px/s^2
  const BOUNCE_VY = -420;   // ê¸°ë³¸ ì í”„ ì†ë„(ìœ„ ìŒìˆ˜)
  const H_SPEED = 70;       // ì¢Œìš° ì´ë™ ì†ë„
  const ARROW_SPEED = 300;  // í™”ì‚´í‘œ í™œì£¼ ì†ë„

  // ì…ë ¥
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{ keys.add(e.key.toLowerCase()); if(e.key==='p'||e.key==='P') paused = !paused; });
  window.addEventListener('keyup',   (e)=>{ keys.delete(e.key.toLowerCase()); });

  // ì˜¨ìŠ¤í¬ë¦° ë²„íŠ¼ + ìº”ë²„ìŠ¤ ì¢Œ/ìš° í„°ì¹˜
  const btnLeft  = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnPause = document.getElementById('btnPause');
  function press(name,on){ if(on) keys.add(name); else keys.delete(name); }
  ['mousedown','touchstart'].forEach(ev=>{
    btnLeft.addEventListener(ev, e=>{ e.preventDefault(); press('touchleft', true); });
    btnRight.addEventListener(ev, e=>{ e.preventDefault(); press('touchright',true); });
  });
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=>{
    btnLeft.addEventListener(ev, e=>{ e.preventDefault(); press('touchleft', false); });
    btnRight.addEventListener(ev, e=>{ e.preventDefault(); press('touchright',false); });
  });
  btnPause.addEventListener('click', ()=>{ paused = !paused; });

  function pointerSide(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches?.[0]?.clientX ?? e.clientX) - rect.left;
    return (x < rect.width/2) ? 'left' : 'right';
  }
  ['touchstart','touchmove'].forEach(ev=>{
    canvas.addEventListener(ev, e=>{
      e.preventDefault();
      const side = pointerSide(e);
      press('touchleft',  side==='left');
      press('touchright', side==='right');
    }, {passive:false});
  });
  ['touchend','touchcancel'].forEach(ev=>{
    canvas.addEventListener(ev, e=>{
      e.preventDefault();
      press('touchleft', false); press('touchright', false);
    }, {passive:false});
  });

  // íƒ€ì¼ íƒ€ì…
  const T = { EMPTY:0, RED:1, WHITE:2, GOAL:3, JUMPER:4, BOMB:5, ARROW_LEFT:6, ARROW_RIGHT:7 };

  // ì—…ìŠ¤ì¼€ì¼ + S ìŠ¤í° ì¶”ì¶œ(20x15 â†’ 40x30)
  function upscaleWithSpawn(baseLines, scale=2){
    let spawn = null;
    const out = [];
    for(let r=0;r<baseLines.length;r++){
      const row = baseLines[r];
      const cS = row.indexOf('S');
      if(cS !== -1){
        const sr = r*scale + Math.floor(scale/2);
        const sc = cS*scale + Math.floor(scale/2);
        spawn = {x: sc, y: sr};
      }
      let scaledRow = '';
      for(const ch of row){
        const rep = (ch==='S'?'.':ch).repeat(scale);
        scaledRow += rep;
      }
      for(let i=0;i<scale;i++) out.push(scaledRow);
    }
    return {lines: out, spawn};
  }
  const up1 = upscaleWithSpawn(level1_base, 2);
  const up2 = upscaleWithSpawn(level2_base, 2);
  const up3 = upscaleWithSpawn(level3_base, 2);
  const up4 = upscaleWithSpawn(level4_base, 2);
  const up5 = upscaleWithSpawn(level5_base, 2);

  // íŒŒì„œ: ë¬¸ì â†’ íƒ€ì¼
  function parseLevel(lines){
    const grid = [];
    for(let r=0;r<ROWS;r++){
      grid[r] = [];
      for(let c=0;c<COLS;c++){
        const ch = (lines[r] && lines[r][c]) || '.';
        grid[r][c] = ch==='R'?T.RED
                  : ch==='W'?T.WHITE
                  : ch==='G'?T.GOAL
                  : ch==='J'?T.JUMPER
                  : ch==='B'?T.BOMB
                  : ch==='<'?T.ARROW_LEFT
                  : ch==='>'?T.ARROW_RIGHT
                  : T.EMPTY;
      }
    }
    return grid;
  }

  const levels = [
    { grid: parseLevel(up1.lines), spawn: up1.spawn || {x:6, y:6} },
    { grid: parseLevel(up2.lines), spawn: up2.spawn || {x:6, y:6} },
    { grid: parseLevel(up3.lines), spawn: up3.spawn || {x:3, y:12} },
    { grid: parseLevel(up4.lines), spawn: up4.spawn || {x:4, y:6} },
    { grid: parseLevel(up5.lines), spawn: up5.spawn || {x:2, y:2} }
  ];

  let stage = 0;
  let grid = levels[stage].grid.map(row=>row.slice());

  // ê³µ
  const ball = { x:0, y:0, radius:3, vx:0, vy:0 };

  // ìƒíƒœ
  let last = performance.now();
  let paused = false;
  let messageTimer = 0;
  let messageText = '';
  let arrowMode = false; // í™”ì‚´í‘œ ìˆ˜í‰ í™œì£¼
  let arrowDir = 0;      // -1/0/+1

  // íƒ€ì´ë¨¸/ì‹¤íŒ¨ ê¸°ë¡ + ìµœì¢… ëª¨ë‹¬ í”Œë˜ê·¸
  let startTime = performance.now();
  let failCount = 0;
  let finalClearShown = false;

  // ì˜¤ë²„ë ˆì´
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovBody  = document.getElementById('ovBody');
  const btnRestartStage1 = document.getElementById('btnRestartStage1');
  const btnCloseOverlay  = document.getElementById('btnCloseOverlay');

  function showOverlay({ title, html, showRestart1=false, isFinal=false }) {
    ovTitle.textContent = title;
    ovBody.innerHTML    = html;
    btnRestartStage1.style.display = showRestart1 ? 'inline-flex' : 'none';
    overlay.classList.remove('hidden');
    finalClearShown = !!isFinal;
    paused = true;
  }
  function hideOverlay(){
    overlay.classList.add('hidden');
    paused = false;
  }
  btnCloseOverlay.addEventListener('click', () => {
    if(finalClearShown){
      stage = 0;
      grid = levels[stage].grid.map(row=>row.slice());
      startTime = performance.now();
      failCount = 0;
      applySpawn();
      finalClearShown = false;
    }
    hideOverlay();
  });
  btnRestartStage1.addEventListener('click', () => {
    stage = 0;
    grid = levels[stage].grid.map(row=>row.slice());
    startTime = performance.now();
    failCount = 0;
    applySpawn();
    finalClearShown = false;
    hideOverlay();
  });

  function applySpawn(){
    const s = levels[stage].spawn || {x:6, y:6};
    ball.x = s.x * TILE + TILE/2;
    ball.y = s.y * TILE;
    ball.vx = 0; ball.vy = 0; arrowMode = false; arrowDir = 0;
  }
  applySpawn();

  function tileAt(px, py){
    const c = Math.floor(px / TILE);
    const r = Math.floor(py / TILE);
    if(c < 0 || c >= COLS || r < 0) return T.RED;   // ì¢Œ/ìš°/ìœ„ëŠ” ë²½
    if(r >= ROWS) return T.EMPTY;                   // ì•„ë˜ ë‚­ë– ëŸ¬ì§€
    return grid[r][c];
  }
  function setTile(c, r, val){ if(r>=0&&c>=0&&r<ROWS&&c<COLS) grid[r][c]=val; }

  // ì…ë ¥ ì²˜ë¦¬
  function handleInput(){
    if(arrowMode){ ball.vx = arrowDir * ARROW_SPEED; return; }
    const left  = keys.has('arrowleft') || keys.has('a') || keys.has('touchleft');
    const right = keys.has('arrowright')|| keys.has('d') || keys.has('touchright');
    if (left && !right)      ball.vx = -H_SPEED;
    else if (right && !left) ball.vx =  H_SPEED;
    else                     ball.vx =  0;
  }

  // ë¬¼ë¦¬
  function physics(dt){
    // í™”ì‚´í‘œ í™œì£¼ ëª¨ë“œ
    if(arrowMode){
      ball.vy = 0;
      let newX = ball.x + ball.vx * dt;
      const signX = Math.sign(ball.vx) || 1;
      const probeX = newX + signX * ball.radius;
      const yTop = ball.y - ball.radius + 1;
      const yMid = ball.y;
      const yBot = ball.y + ball.radius - 1;
      if([yTop,yMid,yBot].some(y=>tileAt(probeX,y)===T.RED)){
        const tileC = Math.floor(probeX / TILE);
        if(signX>0) newX = tileC * TILE - ball.radius - 0.01; else newX = (tileC+1) * TILE + ball.radius + 0.01;
        ball.x = newX;
        // ë²½ ì¶©ëŒ ì‹œ í™œì£¼ ì¢…ë£Œ -> ìˆ˜ì§ íŠ€ê¹€ ì‹œì‘
        arrowMode = false; arrowDir = 0; ball.vx = 0; ball.vy = BOUNCE_VY;
      } else {
        ball.x = newX;
      }
      if(ball.y - ball.radius > H + 4){ gameOver(); }
      return;
    }

    // ì¼ë°˜ ëª¨ë“œ
    ball.vy += GRAVITY * dt;

    // X ì´ë™ + RED ì¶©ëŒ
    let newX = ball.x + ball.vx * dt;
    const signX = Math.sign(ball.vx) || 1;
    const probeX = newX + signX * ball.radius;
    const topY = ball.y - ball.radius + 1;
    const midY = ball.y;
    const botY = ball.y + ball.radius - 1;
    if([topY,midY,botY].some(y=>tileAt(probeX,y)===T.RED)){
      const tileC = Math.floor(probeX / TILE);
      if(signX>0) newX = tileC * TILE - ball.radius - 0.01; else newX = (tileC+1) * TILE + ball.radius + 0.01;
      ball.vx *= -1;
    }
    ball.x = newX;

    // Y ì´ë™
    let newY = ball.y + ball.vy * dt;
    const signY = Math.sign(ball.vy) || 1;
    const probeY = newY + signY * ball.radius;
    const leftX = ball.x - ball.radius + 1, cenX = ball.x, rightX = ball.x + ball.radius - 1;

    const tilesAtProbe = [tileAt(leftX,probeY), tileAt(cenX,probeY), tileAt(rightX,probeY)];
    const hitRedTop = tilesAtProbe.includes(T.RED);

    let hitWhite=false, hitJumper=false, hitBomb=false, arrow=0, whiteCR=null;
    if(ball.vy>0){
      const cIdx = Math.floor(cenX / TILE), rIdx = Math.floor(probeY / TILE);
      if(rIdx>=0&&cIdx>=0&&rIdx<ROWS&&cIdx<COLS){
        const t = grid[rIdx][cIdx];
        if(t===T.WHITE){ hitWhite=true; whiteCR=[cIdx,rIdx]; }
        else if(t===T.JUMPER){ hitJumper=true; }
        else if(t===T.BOMB){ hitBomb=true; }
        else if(t===T.ARROW_LEFT){ arrow=-1; }
        else if(t===T.ARROW_RIGHT){ arrow=+1; }
      }
    }

    if(hitRedTop || hitWhite || hitJumper || hitBomb || arrow){
      if(signY>0){ // ë°”ë‹¥ ì ‘ì´‰
        const tileR = Math.floor(probeY / TILE);
        newY = tileR * TILE - ball.radius - 0.01;
        if(hitBomb){ gameOver(); return; }
        // í™”ì‚´í‘œ: ìˆ˜í‰ í™œì£¼ ëª¨ë“œ ì „í™˜
        if(arrow){ arrowMode = true; arrowDir = arrow; ball.vx = arrow * ARROW_SPEED; ball.vy = 0; ball.y = newY; return; }
        // ì í¼/ì¼ë°˜ íŠ•ê¹€
        ball.vy = hitJumper ? BOUNCE_VY * 1.65 : BOUNCE_VY;
        if(hitWhite && whiteCR) setTile(whiteCR[0], whiteCR[1], T.EMPTY);
      } else { // ì²œì¥ ì¶©ëŒ
        const tileR = Math.floor(probeY / TILE);
        newY = (tileR+1) * TILE + ball.radius + 0.01;
        ball.vy *= -1;
      }
    }

    ball.y = newY;

    // ë‚™ì‚¬
    if(ball.y - ball.radius > H + 4){ gameOver(); return; }

    // Goal
    const c = Math.floor(ball.x / TILE), r = Math.floor(ball.y / TILE);
    if(grid[r] && grid[r][c] === T.GOAL){ nextStage(); }
  }

  function gameOver(){
    failCount++;
    grid = levels[stage].grid.map(row=>row.slice());
    applySpawn();
    showOverlay({ title:'GAME OVER', html:`ìŠ¤í…Œì´ì§€ ${stage+1}ì—ì„œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\në‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!` });
  }

  function nextStage(){
    if(stage === levels.length - 1){
      const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
      showOverlay({
        title:'ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ğŸ‰',
        html:`ê±¸ë¦° ì‹œê°„: <b>${elapsed}ì´ˆ</b><br>ì‹¤íŒ¨ íšŸìˆ˜: <b>${failCount}</b>`,
        showRestart1:true,
        isFinal:true
      });
      return;
    }
    stage++;
    grid = levels[stage].grid.map(row=>row.slice());
    applySpawn();
    messageText = 'STAGE CLEAR';
    messageTimer = 1.2;
    if(stage === 0){ startTime = performance.now(); failCount = 0; }
  }

  // ë Œë”ë§
  function draw(){
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const t = grid[r][c], x = c*TILE, y=r*TILE;
        if(t===T.EMPTY) continue;
        if(t===T.GOAL){
          ctx.fillStyle = '#050505'; ctx.fillRect(x, y, TILE, TILE);
          ctx.strokeStyle = '#0a0a0a'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.RED){
          ctx.fillStyle = '#2b0000'; ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#b66'; ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#600'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
          ctx.fillStyle = '#822'; ctx.fillRect(x+4, y+4, 3, 3); ctx.fillRect(x+9, y+9, 3, 3);
        } else if(t===T.WHITE){
          ctx.fillStyle = '#666'; ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#ddd'; ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#999'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.JUMPER){
          ctx.fillStyle = '#777'; ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#aaa'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.BOMB){
          ctx.fillStyle = '#222'; ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#9bb3d1'; ctx.beginPath(); ctx.arc(x+TILE/2, y+TILE/2, 5, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#334'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.ARROW_LEFT || t===T.ARROW_RIGHT){
          ctx.fillStyle = '#caa440'; ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#6b5615'; ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
          ctx.fillStyle = '#3a2c06'; ctx.beginPath();
          if(t===T.ARROW_RIGHT){ ctx.moveTo(x+5,y+4);ctx.lineTo(x+11,y+8);ctx.lineTo(x+5,y+12); }
          else { ctx.moveTo(x+11,y+4);ctx.lineTo(x+5,y+8);ctx.lineTo(x+11,y+12); }
          ctx.closePath(); ctx.fill();
        }
      }
    }

    // ê³µ
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fill();

    // ê¼¬ë¦¬
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(ball.x - ball.vx*0.05, ball.y - ball.vy*0.05);
    ctx.stroke();

    if(messageTimer>0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,24);
      ctx.fillStyle = '#fffa';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(messageText + ' (Stage ' + (stage+1) + ')', W/2, 16);
    }
  }

  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if(!paused){
      handleInput();
      physics(dt);
      if(messageTimer>0) messageTimer -= dt;
    }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
