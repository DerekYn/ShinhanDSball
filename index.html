<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë¯¸ë‹ˆê²Œì„: íŠ€ëŠ” ê³µ (Stage 1 â†’ 5, S=Spawn, í™”ì‚´í‘œ=ìˆ˜í‰í™œì£¼)</title>
  <style>
    /* ê¸°ë³¸ ë ˆì´ì•„ì›ƒ: ì¤‘ì•™ ì •ë ¬ + ìŠ¤í¬ë¡¤ ì œê±° */
    html, body {
      height: 100%;
      margin: 0;
      background:#111;
      color:#ddd;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden; /* ìŠ¤í¬ë¡¤ ì œê±° */
      touch-action: none;
      overscroll-behavior: contain;
    }
    .wrap {
      display:flex;
      flex-direction:column;
      align-items:center;      /* ê°€ë¡œ ê°€ìš´ë° */
      justify-content:center;  /* ì„¸ë¡œ ê°€ìš´ë° */
      gap:8px;
      width:100%;
      height:100%;
      box-sizing:border-box;
      padding:12px;
    }
    .title {
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 6px;
      text-align: center;
      user-select: none;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#000;
      border:2px solid #444;
      max-width:96vw;
      max-height:80dvh;
    }
    .hud {
      font-size: 14px;
      opacity: .9;
      text-align:center;
      user-select: none;
    }
    .hud kbd {
      background:#222;
      border:1px solid #444;
      border-bottom-color:#222;
      padding:1px 6px;
      border-radius:4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .badge {
      display:inline-block;
      background:#222;
      border:1px solid #444;
      padding:2px 8px;
      border-radius:999px;
      margin-left:6px;
      font-size:12px;
    }

    /* ì˜¤ë²„ë ˆì´ ëª¨ë‹¬ */
    .overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.45); backdrop-filter: blur(2px); z-index:10; }
    .overlay.hidden { display:none; }
    .modal { min-width: min(90vw, 440px); max-width: 92vw; background:#1c1c1c;
      border:1px solid #444; border-radius:12px; padding:16px 18px; box-shadow:0 8px 30px rgba(0,0,0,.5); }
    .modal h2 { margin:0 0 8px; font-size:20px; }
    .modal .body { white-space:pre-line; line-height:1.45; margin-bottom:12px; }
    .actions { display:flex; gap:10px; justify-content:flex-end; }
    .actions button { padding:8px 12px; border-radius:10px; border:1px solid #555; background:#2a2a2a; color:#eee; cursor:pointer; }
    .actions .primary { background:#3b82f6; border-color:#2a6adf; color:#fff; }
    .actions button:active { transform:translateY(1px); }
  </style>
</head>
<body>
<div class="wrap">
  <div class="title" id="pageTitle">ğŸ¦– Shinhan bouncy ball</div>
  <canvas id="game" width="640" height="480"></canvas>
  <div class="hud">
    ë°©í–¥ë§Œ ì¡°ì‘ â†’ <kbd>â—€</kbd>/<kbd>â–¶</kbd> (ë˜ëŠ” <kbd>A</kbd>/<kbd>D</kbd>) Â· ì¼ì‹œì •ì§€ <kbd>P</kbd>
  </div>
</div>

<!-- ê°€ìš´ë° ì˜¤ë²„ë ˆì´ -->
<div id="overlay" class="overlay hidden">
  <div class="modal">
    <h2 id="ovTitle">ì•Œë¦¼</h2>
    <div id="ovBody" class="body">ë‚´ìš©</div>
    <div class="actions">
      <button id="btnRestartStage1" class="primary">ìŠ¤í…Œì´ì§€ 1ë¶€í„° ë‹¤ì‹œ</button>
      <button id="btnCloseOverlay">ë‹«ê¸°</button>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height; // 640x480 ë…¼ë¦¬ í•´ìƒë„
  const TILE = 16;                           // 40x30 ê·¸ë¦¬ë“œ
  const COLS = Math.floor(W / TILE);
  const ROWS = Math.floor(H / TILE);

  // ë¬¼ë¦¬ ìƒìˆ˜
  const GRAVITY = 1200;     // px/s^2
  const BOUNCE_VY = -420;   // ê¸°ë³¸ ì í”„(ìœ„ ìŒìˆ˜)
  const H_SPEED = 70;       // ì¼ë°˜ ì¢Œ/ìš° ì´ë™ ì†ë„
  const ARROW_SPEED = 300;  // í™”ì‚´í‘œ í™œì£¼ ì „ìš© ì†ë„

  // ì…ë ¥
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{ keys.add(e.key.toLowerCase()); if(e.key==='p'||e.key==='P') paused = !paused;});
  window.addEventListener('keyup',   (e)=>{ keys.delete(e.key.toLowerCase()); });

  // íƒ€ì¼ íƒ€ì…
  const T = { EMPTY:0, RED:1, WHITE:2, GOAL:3, JUMPER:4, BOMB:5, ARROW_LEFT:6, ARROW_RIGHT:7 };

  // ====== ìŠ¤í…Œì´ì§€ ì›ë³¸(20x15, S=Spawn ì§€ì›) ======
  // Stage 1
  const level1_base = [
    "RRRRRRRRRRRRRRRRRRRR",
    "R..................R",
    "R.S................R",
    "R..................R",
    "R..................R",
    "R.....RRRRRRR......R",
    "R....RR..RRRR......R",
    "R...RRR.R.RRR......R",
    "R..RRRR.R.RRR......R",
    "R.RRRRR..RRRR......R",
    "RRRRRRRRR...RWWWWWWR",
    "RRRRRRRRR.RRR......R",
    "RRRRRRRRRR.RR......R",
    "RRRRRRRRRRR.R......G",
    "RRRRRRRRR...RRRRRRRR"
  ];

  // Stage 2
  const level2_base = [
    "RRRRRRRRRRRRRRRRRRRR",
    "R..................R",
    "R.S................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "RRRRR..............G",
    "RRRRR....RRRR.RRRRRR",
    "RRRRR.RRRRR........R",
    "RRRRR.RRRRR........R"
  ];

  // Stage 3 (ì í¼)
  const level3_base = [
    "RRRRRRRRRRRRRRRRRRRR",
    "R..................R",
    "R.S................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "R..............JJ..R",
    "R...........J......G",
    "R........J........RR",
    "R.....J............R",
    "R...R..............R",
    "R..R...............R",
    "R..................R",
    "RRRRR..............R"
  ];

  // Stage 4 (S ë¯¸ì§€ì • â†’ ê¸°ë³¸ ìŠ¤í° ì¢Œí‘œ ì‚¬ìš©)
  const level4_base = [
    "RRRRRRRRRRRRRRRRRRRR",
    "R.S................R",
    "R..................R",
    "R..................R",
    "R..................R",
    "RRRRRWWWWWRRRRRRRRRR",
    "R...........R......R",
    "R...........R......R",
    "R...........R......R",
    "R...........R......R",
    "R...........R......R",
    "R..................R",
    "R..................G",
    "R....RRRRWWWWJ.RRRRR",
    "R..............RRRRR"
  ];

  // Stage 5 (í­íƒ„/í™”ì‚´í‘œ) - ì‚¬ìš©ìê°€ ì§€ì •í•œ ìµœì‹ ë³¸
  const level5_base = [
    "RRRRRRRRRRRRRRRRRRRR",
    "R................S.R",
    "R..................R",
    "R..................R",
    "R.....RRBRRRBRRRRRRR",
    "R................R.R",
    "R................R.R",
    "RBBRRR>..........R.R",
    "R......BBBBBB....R.R",
    "R................R.R",
    "R................R.R",
    "R................R.R",
    "R.....RRRRRRRRRRRR.R",
    "R..................G",
    "R...>..............G"
  ];

  // ì—…ìŠ¤ì¼€ì¼ + S ìŠ¤í° ì¶”ì¶œ(20x15 â†’ 40x30)
  function upscaleWithSpawn(baseLines, scale=2){
    let spawn = null; // íƒ€ì¼ ì¢Œí‘œ(ì—…ìŠ¤ì¼€ì¼ í›„)
    const out = [];
    for(let r=0;r<baseLines.length;r++){
      const row = baseLines[r];
      const cS = row.indexOf('S');
      if(cS !== -1){
        const sr = r*scale + Math.floor(scale/2);
        const sc = cS*scale + Math.floor(scale/2);
        spawn = {x: sc, y: sr};
      }
      let scaledRow = '';
      for(const ch of row){
        const rep = (ch==='S'?'.':ch).repeat(scale);
        scaledRow += rep;
      }
      for(let i=0;i<scale;i++) out.push(scaledRow);
    }
    return {lines: out, spawn};
  }

  const up1 = upscaleWithSpawn(level1_base, 2);
  const up2 = upscaleWithSpawn(level2_base, 2);
  const up3 = upscaleWithSpawn(level3_base, 2);
  const up4 = upscaleWithSpawn(level4_base, 2);
  const up5 = upscaleWithSpawn(level5_base, 2);

  // íŒŒì„œ: ë¬¸ì â†’ íƒ€ì¼
  function parseLevel(lines){
    const grid = [];
    for(let r=0;r<ROWS;r++){
      grid[r] = [];
      for(let c=0;c<COLS;c++){
        const ch = (lines[r] && lines[r][c]) || '.';
        grid[r][c] = ch==='R'?T.RED
                  : ch==='W'?T.WHITE
                  : ch==='G'?T.GOAL
                  : ch==='J'?T.JUMPER
                  : ch==='B'?T.BOMB
                  : ch==='<'?T.ARROW_LEFT
                  : ch==='>'?T.ARROW_RIGHT
                  : T.EMPTY;
      }
    }
    return grid;
  }

  const levels = [
    { grid: parseLevel(up1.lines), spawn: up1.spawn || {x:6, y:6} },
    { grid: parseLevel(up2.lines), spawn: up2.spawn || {x:6, y:6} },
    { grid: parseLevel(up3.lines), spawn: up3.spawn || {x:3, y:12} },
    { grid: parseLevel(up4.lines), spawn: up4.spawn || {x:4, y:6} },  // stage4 ì•ˆì „ ìŠ¤í°(ê¸°ë³¸ê°’)
    { grid: parseLevel(up5.lines), spawn: up5.spawn || {x:2, y:2} }
  ];

  let stage = 0;
  let grid = levels[stage].grid.map(row=>row.slice());

  // ê³µ
  const ball = { x:0, y:0, radius:3, vx:0, vy:0 };

  // ìƒíƒœ
  let last = performance.now();
  let paused = false;
  let messageTimer = 0;
  let messageText = '';
  let arrowMode = false; // í™”ì‚´í‘œ ìˆ˜í‰ í™œì£¼
  let arrowDir = 0;      // -1/0/+1

  // ê¸°ë¡(ìµœì¢… ê²°ê³¼ìš©)
  let startTime = performance.now();
  let failCount = 0;

  // ===== Overlay (modal) =====
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovBody  = document.getElementById('ovBody');
  const btnRestartStage1 = document.getElementById('btnRestartStage1');
  const btnCloseOverlay  = document.getElementById('btnCloseOverlay');

  function showOverlay({ title, html, showRestart1=false }) {
    ovTitle.textContent = title;
    ovBody.innerHTML    = html;
    btnRestartStage1.style.display = showRestart1 ? 'inline-flex' : 'none';
    overlay.classList.remove('hidden');
    paused = true;
  }
  function hideOverlay(){
    overlay.classList.add('hidden');
    paused = false;
  }
  btnCloseOverlay?.addEventListener('click', () => hideOverlay());
  btnRestartStage1?.addEventListener('click', () => {
    // ìŠ¤í…Œì´ì§€1ë¶€í„° ì¬ì‹œì‘
    stage = 0;
    grid = levels[stage].grid.map(row=>row.slice());
    startTime = performance.now();
    failCount = 0;
    applySpawn();
    hideOverlay();
  });

  function applySpawn(){
    const s = levels[stage].spawn || {x:6, y:6};
    ball.x = s.x * TILE + TILE/2;
    ball.y = s.y * TILE; // íƒ€ì¼ ê¼­ëŒ€ê¸°
    ball.vx = 0; ball.vy = 0; arrowMode = false; arrowDir = 0;
  }
  applySpawn();

  function tileAt(px, py){
    const c = Math.floor(px / TILE);
    const r = Math.floor(py / TILE);
    if(c < 0 || c >= COLS || r < 0) return T.RED;   // ì¢Œ/ìš°/ìœ„ëŠ” ë²½
    if(r >= ROWS) return T.EMPTY;                   // ì•„ë˜ ë‚­ë– ëŸ¬ì§€
    return grid[r][c];
  }
  function setTile(c, r, val){ if(r>=0&&c>=0&&r<ROWS&&c<COLS) grid[r][c]=val; }

  // ì…ë ¥: í™”ì‚´í‘œ í™œì£¼ ì¤‘ì—ëŠ” ë¬´ì‹œ, ì•„ë‹ ë•Œë§Œ ì¢Œìš° ì ìš©
  function handleInput(){
    if(arrowMode){ ball.vx = arrowDir * ARROW_SPEED; return; }
    if(keys.has('arrowleft') || keys.has('a')){ ball.vx = -H_SPEED; }
    else if(keys.has('arrowright') || keys.has('d')){ ball.vx = H_SPEED; }
    else { ball.vx = 0; }
  }

  function physics(dt){
    // í™”ì‚´í‘œ í™œì£¼ ëª¨ë“œ: ì¤‘ë ¥/ìˆ˜ì§ ì •ì§€, ìˆ˜í‰ë§Œ ì´ë™
    if(arrowMode){
      ball.vy = 0;
      let newX = ball.x + ball.vx * dt;
      const signX = Math.sign(ball.vx) || 1;
      const probeX = newX + signX * ball.radius;
      const yTop = ball.y - ball.radius + 1;
      const yMid = ball.y;
      const yBot = ball.y + ball.radius - 1;
      if([yTop,yMid,yBot].some(y=>tileAt(probeX,y)===T.RED)){
        const tileC = Math.floor(probeX / TILE);
        if(signX>0) newX = tileC * TILE - ball.radius - 0.01; else newX = (tileC+1) * TILE + ball.radius + 0.01;
        ball.x = newX;
        // ë²½ì— ë‹¿ìœ¼ë©´ í™œì£¼ ì¢…ë£Œ â†’ ì¦‰ì‹œ ìˆ˜ì§ íŠ•ê¹€ ì‹œì‘
        arrowMode = false; arrowDir = 0; ball.vx = 0; ball.vy = BOUNCE_VY;
      } else {
        ball.x = newX;
      }
      // ì•ˆì „ ì²´í¬
      if(ball.y - ball.radius > H + 4){ gameOver(); }
      return;
    }

    // ===== ì¼ë°˜ ëª¨ë“œ =====
    ball.vy += GRAVITY * dt;

    // X ì´ë™ + RED ì¶©ëŒ
    let newX = ball.x + ball.vx * dt;
    const signX = Math.sign(ball.vx) || 1;
    const probeX = newX + signX * ball.radius;
    const topY = ball.y - ball.radius + 1;
    const midY = ball.y;
    const botY = ball.y + ball.radius - 1;
    if([topY,midY,botY].some(y=>tileAt(probeX,y)===T.RED)){
      const tileC = Math.floor(probeX / TILE);
      if(signX>0) newX = tileC * TILE - ball.radius - 0.01; else newX = (tileC+1) * TILE + ball.radius + 0.01;
      ball.vx *= -1;
    }
    ball.x = newX;

    // Y ì´ë™
    let newY = ball.y + ball.vy * dt;
    const signY = Math.sign(ball.vy) || 1;
    const probeY = newY + signY * ball.radius;
    const leftX = ball.x - ball.radius + 1, cenX = ball.x, rightX = ball.x + ball.radius - 1;

    const tilesAtProbe = [tileAt(leftX,probeY), tileAt(cenX,probeY), tileAt(rightX,probeY)];
    const hitRedTop = tilesAtProbe.includes(T.RED);

    let hitWhite=false, hitJumper=false, hitBomb=false, arrow=0, whiteCR=null;
    if(ball.vy>0){
      const cIdx = Math.floor(cenX / TILE), rIdx = Math.floor(probeY / TILE);
      if(rIdx>=0&&cIdx>=0&&rIdx<ROWS&&cIdx<COLS){
        const t = grid[rIdx][cIdx];
        if(t===T.WHITE){ hitWhite=true; whiteCR=[cIdx,rIdx]; }
        else if(t===T.JUMPER){ hitJumper=true; }
        else if(t===T.BOMB){ hitBomb=true; }
        else if(t===T.ARROW_LEFT){ arrow=-1; }
        else if(t===T.ARROW_RIGHT){ arrow=+1; }
      }
    }

    if(hitRedTop || hitWhite || hitJumper || hitBomb || arrow){
      if(signY>0){ // ë°”ë‹¥ ì ‘ì´‰
        const tileR = Math.floor(probeY / TILE);
        newY = tileR * TILE - ball.radius - 0.01;
        if(hitBomb){ gameOver(); return; }
        // í™”ì‚´í‘œ: ìˆ˜í‰ í™œì£¼ ëª¨ë“œë¡œ ì „í™˜
        if(arrow){ arrowMode = true; arrowDir = arrow; ball.vx = arrow * ARROW_SPEED; ball.vy = 0; ball.y = newY; return; }
        // ì¼ë°˜/ì í¼ íŠ•ê¹€
        ball.vy = hitJumper ? BOUNCE_VY * 1.65 : BOUNCE_VY;
        if(hitWhite && whiteCR) setTile(whiteCR[0], whiteCR[1], T.EMPTY);
      } else { // ì²œì¥
        const tileR = Math.floor(probeY / TILE);
        newY = (tileR+1) * TILE + ball.radius + 0.01;
        ball.vy *= -1;
      }
    }

    ball.y = newY;

    // ë‚™ì‚¬
    if(ball.y - ball.radius > H + 4){ gameOver(); return; }

    // Goal
    const c = Math.floor(ball.x / TILE), r = Math.floor(ball.y / TILE);
    if(grid[r] && grid[r][c] === T.GOAL){ nextStage(); }
  }

  function gameOver(){
    failCount++;
    grid = levels[stage].grid.map(row=>row.slice());
    applySpawn();
    showOverlay({
      title: 'GAME OVER',
      html: `ìŠ¤í…Œì´ì§€ ${stage+1}ì—ì„œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\në‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!`
    });
  }

  function nextStage(){
    // ë§ˆì§€ë§‰ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´?
    if(stage === levels.length - 1){
      const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
      showOverlay({
        title: 'ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ğŸ‰',
        html: `ê±¸ë¦° ì‹œê°„: <b>${elapsed}ì´ˆ</b><br>ì‹¤íŒ¨ íšŸìˆ˜: <b>${failCount}</b>`,
        showRestart1: true
      });
      return;
    }
    // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ
    stage++;
    grid = levels[stage].grid.map(row=>row.slice());
    applySpawn();

    // (ì„ íƒ) ìº”ë²„ìŠ¤ ë‚´ ë©”ì‹œì§€ í‘œì‹œ
    messageText = 'STAGE CLEAR';
    messageTimer = 1.2;

    // ìŠ¤í…Œì´ì§€1 ì§„ì… ì‹œ ê¸°ë¡ ì´ˆê¸°í™”
    if(stage === 0){
      startTime = performance.now();
      failCount = 0;
    }
  }

  // ë Œë”ë§
  function draw(){
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const t = grid[r][c];
        const x = c*TILE, y=r*TILE;
        if(t===T.EMPTY) continue;
        if(t===T.GOAL){
          ctx.fillStyle = '#050505';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.strokeStyle = '#0a0a0a';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.RED){
          ctx.fillStyle = '#2b0000';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#b66';
          ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#600';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
          ctx.fillStyle = '#822';
          ctx.fillRect(x+4, y+4, 3, 3);
          ctx.fillRect(x+9, y+9, 3, 3);
        } else if(t===T.WHITE){
          ctx.fillStyle = '#666';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#ddd';
          ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#999';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.JUMPER){
          ctx.fillStyle = '#777';
          ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#aaa';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.BOMB){
          ctx.fillStyle = '#222';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#9bb3d1';
          ctx.beginPath();
          ctx.arc(x+TILE/2, y+TILE/2, 5, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = '#334';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
        } else if(t===T.ARROW_LEFT || t===T.ARROW_RIGHT){
          ctx.fillStyle = '#caa440';
          ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
          ctx.strokeStyle = '#6b5615';
          ctx.strokeRect(x+0.5, y+0.5, TILE-1, TILE-1);
          ctx.fillStyle = '#3a2c06';
          ctx.beginPath();
          if(t===T.ARROW_RIGHT){ctx.moveTo(x+5,y+4);ctx.lineTo(x+11,y+8);ctx.lineTo(x+5,y+12);} 
          else {ctx.moveTo(x+11,y+4);ctx.lineTo(x+5,y+8);ctx.lineTo(x+11,y+12);} 
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // ê³µ
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fill();

    // ê¼¬ë¦¬
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(ball.x - ball.vx*0.05, ball.y - ball.vy*0.05);
    ctx.stroke();

    // ìƒë‹¨ ë©”ì‹œì§€ ë°”(ì„ íƒ)
    if(messageTimer>0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,24);
      ctx.fillStyle = '#fffa';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(messageText + ' (Stage ' + (stage+1) + ')', W/2, 16);
    }
  }

  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if(!paused){
      handleInput();
      physics(dt);
      if(messageTimer>0) messageTimer -= dt;
    }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
